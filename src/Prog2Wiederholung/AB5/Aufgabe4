

A)


int[] arr = {1, 2, 3};
for (int element : arr) {
    element = 42;
}
â“Was passiert?
Java kopiert bei jedem Schleifendurchlauf den Wert von arr[i] in die Variable element.

element = 42 Ã¤ndert nur die Kopie, nicht das Originalelement im Array.

ğŸ“Œ Ergebnis:
Das Array bleibt unverÃ¤ndert: arr = {1, 2, 3}.

ğŸ’¡ ErklÃ¤rung:
Primitive Datentypen (wie int) werden per Wert Ã¼bergeben.
Die Schleifenvariable element ist also eine Kopie und keine Referenz auf das Array-Element.


B)


DynArray<Integer> arr = new DynArray<>();
arr.add(1);
arr.add(2);
arr.add(3);

for (Integer element : arr) {
    element = 42;
}
â“Was passiert?
Integer ist ein Wrapper-Typ und damit unverÃ¤nderlich (immutable).

Auch hier wird eine Kopie der Referenz auf das Objekt Integer Ã¼bergeben.

element = 42 weist die lokale Schleifenvariable auf ein neues Objekt
â€“ aber das hat keine Auswirkung auf das DynArray.

ğŸ“Œ Ergebnis:
Das DynArray bleibt ebenfalls unverÃ¤ndert: [1, 2, 3].

ğŸ’¡ ErklÃ¤rung:
Selbst bei Objekten: Wenn du die Schleifenvariable neu zuweist (element = 42),
Ã¤nderst du nicht das, worauf das Originalarray zeigt â€“ du ersetzt nur die lokale Referenz.




C)


DynArray<IntKiste> arr = new DynArray<>();
arr.add(new IntKiste(1));
arr.add(new IntKiste(2));
arr.add(new IntKiste(3));

for (IntKiste element : arr) {
    element.set(42);
}
â“Was passiert?
Hier wird eine Referenz auf das Objekt IntKiste Ã¼bergeben.

Mit element.set(42) verÃ¤nderst du den Zustand des Objekts, auf das element zeigt.

ğŸ“Œ Ergebnis:
Alle Objekte im DynArray enthalten jetzt 42:
[IntKiste(42), IntKiste(42), IntKiste(42)].

ğŸ’¡ ErklÃ¤rung:
Objektreferenzen werden kopiert, aber die Objekte selbst bleiben dieselben.
Wenn du set(...) aufrufst, Ã¤nderst du das Objekt direkt.


--TIPPS--


âœ… Vergleich: Was passiert in der for-each-Schleife wirklich?
| Fall                 | Was wird verÃ¤ndert?               | Hat es Auswirkungen auf das Original? | Warum?                                                                                                          |
| -------------------- | --------------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| `int[] arr`          | Nur eine **Kopie** des Wertes     | âŒ Nein                                | `int` ist ein einfacher Wert. Die Schleife arbeitet nur mit einer Kopie â€“ das Original im Array bleibt gleich.  |
| `DynArray<Integer>`  | Nur die **Referenz** wird kopiert | âŒ Nein                                | `Integer` ist ein Objekt, aber **unverÃ¤nderbar** (immutable). Das neue `42` ersetzt nur die Kopie der Referenz. |
| `DynArray<IntKiste>` | Die **Daten im Objekt** selbst    | âœ… Ja                                  | `IntKiste` ist verÃ¤nderbar (mutable). Du greifst Ã¼ber die Referenz direkt auf das Objekt zu und Ã¤nderst es.     |
| -------------------- | --------------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------------------- |


ğŸ” Einfach erklÃ¤rt:
Bei Zahlen (int) wird nur eine Kopie gemacht â†’ keine Ã„nderung.

Bei Objekten wie Integer wird auch nur eine Referenz kopiert â†’ aber da Integer nicht verÃ¤nderbar ist, passiert nichts.

Bei Objekten wie IntKiste, die verÃ¤nderbar sind, kannst du das echte Objekt Ã¤ndern, weil du es Ã¼ber die Referenz erreichst.
